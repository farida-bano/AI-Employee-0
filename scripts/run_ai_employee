import os
import sys
import fcntl
import time
import logging
import logging.handlers
import argparse
import subprocess
import datetime # Added for weekly briefing

# --- Configuration ---
LOG_FILE = 'logs/ai_employee.log'
LOCK_FILE = 'ai_employee.lock'
LOG_MAX_BYTES = 5 * 1024 * 1024  # 5 MB
LOG_BACKUP_COUNT = 5
DEFAULT_INTERVAL_SECONDS = 5 * 60 # 5 minutes
LAST_BRIEFING_FILE = 'last_ceo_briefing.timestamp' # Added for weekly briefing

# --- Logger Setup ---
os.makedirs(os.path.dirname(LOG_FILE), exist_ok=True)
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

# File handler for logging to a file with rotation
file_handler = logging.handlers.RotatingFileHandler(
    LOG_FILE, maxBytes=LOG_MAX_BYTES, backupCount=LOG_BACKUP_COUNT
)
file_handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))
logger.addHandler(file_handler)

# Console handler for logging to stdout/stderr (optional, primarily for 'once' or 'status' modes)
console_handler = logging.StreamHandler(sys.stdout)
console_handler.setFormatter(logging.Formatter('%(levelname)s - %(message)s'))
logger.addHandler(console_handler)


class SingleInstance:
    def __init__(self, lock_file):
        self.lock_file = lock_file
        self.fd = None

    def acquire(self):
        self.fd = open(self.lock_file, 'w')
        try:
            fcntl.flock(self.fd, fcntl.LOCK_EX | fcntl.LOCK_NB)
            return True
        except IOError:
            logger.warning("Another instance is already running.")
            return False

    def release(self):
        if self.fd:
            fcntl.flock(self.fd, fcntl.LOCK_UN)
            self.fd.close()
        if os.path.exists(self.lock_file):
            os.remove(self.lock_file)

# --- Core Logic Placeholder ---
def run_vault_watcher():
    logger.info("Running vault-watcher (file_watcher.py)...")
    try:
        # Assuming file_watcher.py is meant to be run directly
        result = subprocess.run(
            [sys.executable, "Bronze/file_watcher.py"],
            capture_output=True,
            text=True,
            check=True
        )
        logger.info(f"vault-watcher output: {result.stdout.strip()}")
    except subprocess.CalledProcessError as e:
        logger.error(f"vault-watcher failed with error: {e}")
        logger.error(f"vault-watcher stderr: {e.stderr.strip()}")
    except FileNotFoundError:
        logger.error(f"Bronze/file_watcher.py not found. Please ensure the path is correct.")
    except Exception as e:
        logger.error(f"An unexpected error occurred while running vault-watcher: {e}")
    logger.info("vault-watcher finished.")

def run_ralph_wiggum_loop():
    logger.info("Running Ralph Wiggum Autonomous Loop...")
    needs_action_path = "Bronze/Needs_Action"
    if not os.path.exists(needs_action_path):
        logger.info(f"Directory '{needs_action_path}' does not exist. No tasks to process.")
        return

    task_files = [f for f in os.listdir(needs_action_path) if os.path.isfile(os.path.join(needs_action_path, f))]

    if not task_files:
        logger.info("No pending tasks in Bronze/Needs_Action.")
        return

    for task_file in task_files:
        full_task_path = os.path.join(needs_action_path, task_file)
        logger.info(f"Initiating Ralph Wiggum Loop for task: {full_task_path}")
        try:
            result = subprocess.run(
                [sys.executable, "scripts/ralph_wiggum_loop.py", full_task_path],
                capture_output=True,
                text=True,
                check=False # Do not raise an exception for non-zero exit codes
            )
            if result.stdout:
                logger.info(f"Ralph Wiggum Loop stdout for {task_file}:\n{result.stdout.strip()}")
            if result.stderr:
                logger.error(f"Ralph Wiggum Loop stderr for {task_file}:\n{result.stderr.strip()}")
            if result.returncode != 0:
                logger.error(f"Ralph Wiggum Loop for {task_file} exited with non-zero status: {result.returncode}")
        except FileNotFoundError:
            logger.error(f"scripts/ralph_wiggum_loop.py not found. Please ensure the path is correct.")
        except Exception as e:
            logger.error(f"An unexpected error occurred while running Ralph Wiggum Loop for {task_file}: {e}")
    logger.info("Ralph Wiggum Autonomous Loop finished processing pending tasks.")

def run_task_planner():
    # logger.info("Running task-planner (task_processor.py)...")
    # try:
    #     result = subprocess.run(
    #         [sys.executable, "Bronze/task_processor.py"],
    #         capture_output=True,
    #         text=True,
    #         check=True
    #     )
    #     logger.info(f"task-planner output: {result.stdout.strip()}")
    # except subprocess.CalledProcessError as e:
    #     logger.error(f"task-planner failed with error: {e}")
    #     logger.error(f"task-planner stderr: {e.stderr.strip()}")
    # except FileNotFoundError:
    #     logger.error(f"Bronze/task_processor.py not found. Please ensure the path is correct.")
    # except Exception as e:
    #     logger.error(f"An unexpected error occurred while running task-planner: {e}")
    # logger.info("task-planner finished.")

    # New implementation: Delegate to Ralph Wiggum Loop
    logger.info("Task processing delegated to Ralph Wiggum Autonomous Loop.")
    run_ralph_wiggum_loop()
    logger.info("Task processing by Ralph Wiggum Autonomous Loop finished.")

def run_ceo_briefing(): # Added function
    logger.info("Generating CEO Weekly Briefing (ceo-briefing/scripts/generate_briefing.py)...")
    try:
        result = subprocess.run(
            [sys.executable, "ceo-briefing/scripts/generate_briefing.py"],
            capture_output=True,
            text=True,
            check=True
        )
        logger.info(f"CEO Briefing output: {result.stdout.strip()}")
    except subprocess.CalledProcessError as e:
        logger.error(f"CEO Briefing failed with error: {e}")
        logger.error(f"CEO Briefing stderr: {e.stderr.strip()}")
    except FileNotFoundError:
        logger.error(f"ceo-briefing/scripts/generate_briefing.py not found. Please ensure the path is correct.")
    except Exception as e:
        logger.error(f"An unexpected error occurred while generating CEO Briefing: {e}")
    logger.info("CEO Weekly Briefing generation finished.")

def run_once():
    logger.info("Running in 'once' mode.")
    run_vault_watcher()
    run_task_planner()
    run_ceo_briefing() # Added this line
    logger.info("'once' mode finished.")

def run_daemon(interval):
    logger.info(f"Running in 'daemon' mode with interval {interval} seconds.")
    try:
        while True:
            run_vault_watcher()
            run_task_planner()

            # Check for weekly CEO briefing
            now = datetime.datetime.now()
            last_briefing_time = None
            if os.path.exists(LAST_BRIEFING_FILE):
                with open(LAST_BRIEFING_FILE, 'r') as f:
                    try:
                        last_briefing_time = datetime.datetime.fromisoformat(f.read().strip())
                    except ValueError:
                        logger.warning(f"Invalid timestamp in {LAST_BRIEFING_FILE}. Resetting.")

            # Run briefing if it's been a week or more since the last run
            # Or if it's never run before
            if last_briefing_time is None or (now - last_briefing_time).days >= 7:
                logger.info("It's time to generate the weekly CEO briefing.")
                run_ceo_briefing()
                with open(LAST_BRIEFING_FILE, 'w') as f:
                    f.write(now.isoformat())
            else:
                logger.info(f"Next CEO briefing in {7 - (now - last_briefing_time).days} days.")

            logger.info(f"Sleeping for {interval} seconds...")
            time.sleep(interval)
    except KeyboardInterrupt:
        logger.info("'daemon' mode stopped by user.")
    except Exception as e:
        logger.error(f"Error in daemon mode: {e}")

def show_status():
    logger.info("Showing status.")
    needs_action_path = "Bronze/Needs_Action"
    inbox_path = "Bronze/Inbox"

    needs_action_count = 0
    if os.path.exists(needs_action_path):
        needs_action_count = len([name for name in os.listdir(needs_action_path) if os.path.isfile(os.path.join(needs_action_path, name))])
    
    inbox_count = 0
    if os.path.exists(inbox_path):
        inbox_count = len([name for name in os.listdir(inbox_path) if os.path.isfile(os.path.join(inbox_path, name))])

    logger.info(f"Active tasks (Bronze/Needs_Action): {needs_action_count}")
    logger.info(f"Inbox items (Bronze/Inbox): {inbox_count}")

def main():
    parser = argparse.ArgumentParser(description="AI Employee Scheduler")
    parser.add_argument("mode", choices=["daemon", "once", "status"], help="Operation mode")
    parser.add_argument("--interval", type=int, default=DEFAULT_INTERVAL_SECONDS,
                        help=f"Interval in seconds for daemon mode (default: {DEFAULT_INTERVAL_SECONDS}).")

    args = parser.parse_args()

    # Lock file mechanism applies to 'daemon' mode to prevent multiple instances
    if args.mode == "daemon":
        single_instance = SingleInstance(LOCK_FILE)
        if not single_instance.acquire():
            sys.exit(1)
        try:
            run_daemon(args.interval)
        finally:
            single_instance.release()
    elif args.mode == "once":
        run_once()
    elif args.mode == "status":
        show_status()

if __name__ == "__main__":
    main()
